数据结构内容:基本数据组织和数据处理方法
地位:承上启下
关系:基本的算法设计
求解问题:数据逻辑结构(提炼)->数据存储结构(设计)->数据基本运算:算法(实现)
学习方法:
        1.理解各种数据结构的逻辑特性和存储结构设计
        2.掌握各种数据结构算法设计的基本方法
        3.利用各种数据结构来求解实际问题
        4.演绎和归纳相结合
1.1.1数据结构定义:
        1.数据:所有能够输入到计算机中,且能被计算机处理的符好的集合
          *数据结构中主要讨论结构化数据
        2.数据元素:是数据(集合)中的一个"个体",是数据的基本单位
        3.数据项:数据项是用来描述数据元素的,它是数据的最小单位
        4.数据对象:具有相同性质的若干个数据元素的集合,如整数数据对象是所有整数的集合
          *默认情况下,数据结构中讨论的数据都是数据对象
          
        5.数据结构:带结构的数据元素的集合
          *数据结构=数据对象+结构
数据结构的构成:  逻辑结构->存储结构->数据运算
        1.数据元素之间的逻辑关系-->数据的逻辑结构
        2.数据元素及其关系再计算机存储器中的存储方式-->数据的存储结构(或物理结构)
        3.施加在该数据上的操作-->数据运算
二元组:  一种通用的逻辑结构表示方法
        B=(D,R)
        其中B是一种数据结构,它由数据元素的集合D和D上二元关系的集合R所组成
        其中:     
          D={d[i]|1<=i<=n,n>=0};数据元素的集合
          B={r[j]|1<=j<=m,m>=0};关系的集合
        每个关系的用若干个序偶来表示:
          序偶<x,y>(x,y属于D)-->x为第一元素,y为第二元素
          x为y的前趋元素
          y为x的后继元素
          若某个元素没有前趋元素,则称该元素为开始元素;若某个元素没有后继元素,则称该元素为终端元素
          *序偶<x,y>表示x.y是有向的,序偶(x,y)表示x.y是无向的
数据的存储结构表示:
        数据在计算机存储器中的存储方式的存储结构,他是面向程序员的
          逻辑结构---映射--->存储结构
        需要满足的要求:
          1.存储所有元素
          2.存储数据元素间的关系 
结构体数组Stud:
        struct
        {  int no;        //存储学号
           char name[8];  //存储姓名
           char sex[2];   //存储性别
           char class[4]; //存储班号
         }Stud[7]={{1,"张斌","男","9901"},....}; 
顺序存储结构:
         两个逻辑上相邻元素直接映射到存储空间,在存储空间中也相邻.
       特点:
         1.所有元素占用一整块内存空间
         2.逻辑上相邻的元素,物理上也相邻
链表StudType:
        typedef struct studnode
        {  int no;                 //存储学号
           char name[8];           //存储姓名
           char sex[2];            //存储性别
           char class[4];          //存储班号
           struct studnode *next   //存储指向下一个学生的指针
        }StudType
链式存储结构:
        特点:
          1.一个逻辑元素用一个节点存储,每个节点单独分配,所有节点的地址不一定是连续的.
          2.用指针来表示逻辑关系.
数据运算:
        数据运算是对数据的操作.分为两个层次:运算描述和运算实现
          对于"学生表"这种数据结构,可以进行一系列运算
          增删查学生的... ---运算描述
1.1.2逻辑结构类型: 
        1.集合:
          元素之间关系:无
          特点:只是同属于一个集合,是最松散的
        2.线性结构:
          元素关系:一对一
          特点:开始元素和终端元素都是唯一的,除此之外,其余元素都有且仅有一个前趋元素和一个后继元素.
        3.树形结构:
          元素关系:一对多
          特点:开始元素唯一,终端元素不唯一.除终端元素外,每个元素有一个或多个后续元素;除开始元素外,每个元素有且仅有一个前趋元素.
1.1.4数据类型和抽象数据类型
1.数据类型:
        在高级程序语言中提供了多种数据类型,不同数据类型的变量,其所能取的值的范围不同,所能进行的操作不同
        *是一个值的集合和定义在此集合上的一组操作总称
        ej.   int-->  -32768~32767--值的集合
                 -->  + - * /     --一组操作          
数据类型和数据结构的关系:数据类型就是已经实现了的数据结构          
2.抽象数据类型:
        抽象数据类型(ADT)指的是从求解问题的数学模型中抽象出来的数据逻辑结构和运算(抽象运算),而不考虑计算机的具体实现
        *抽象数据类型=逻辑结构+抽象运算
ADT Complex
{ 
        数据对象:D={e1,e2|e1,e2均为实数}
        数据关系:R={<e1,e2>|e1是复数的实部,e2是复数的虚部
        AssignComplex(&z,v1,v2)     //构造复数Z
        DestroyComplex(&z)          //复数z被销毁
        GetReal(z,&real)            //返回复数z的实部值
        GetImag(z,&Imag)            //返回复数z的虚部值
        Add(z1,z2,&sum)             //返回两个复数的z1 z2的和
}ADT Complex
抽象数据类型实质:对一个求解问题的形式化描述(与计算机无关),程序员可以在理解基础上实现它.      

1.1.5数据结构求解问题的过程
        ADT =逻辑结构+抽象运算(功能描述)   ---问题描述
        映射到     ->>   存储结构1...n          ---设计存储结构
        运算实现   ->>   算法1...n              ---算法设计 
        分析出     ->>   最佳算法               ---算法分析

1.2算法及其描述
1.2.1什么是算法:
        数据元素之间的关系有逻辑关系和物理关系,对应的运算有基于逻辑结构的运算描述和基于存储结构的运算实现.
        通常把基于存储结构的运算实现的步骤或过程称为算法
        *运算功能描述  --基于存储结构-->运算功能实现(算法)
算法的五个重要特性:
        1.有穷性:在有穷步后结束,算法能够停机
        2.确定性:无二义
        3.可行性:可通过基本运算有限次执行来实现,也就是算法中每一个动作能够被机械的执行
        4.有输入输出:表示存在数据处理
1.2.2算法描述
一般格式:
        返回值  算法对应的函数名(形参列表)
  {     //临时定义的变量;
        //实现由输入参数到输出参数的操作
        ...
  }
        返回值:通常为bool类型,表示算法是否成功
        形参列表:由输入型参数(算法输入)和输出型参数(算法输出)构成
如何描述输出型参数:   用引用运算符"&"用于描述输出型参数  
        普通参数  -->单向传递
        引用参数  -->双向传递,实现同步    "&"
1.3算法分析基础  
        分析算法占用的资源: 1.CPU时间    --->时间性能分析
                           2.内存空间   --->空间性能分析
算法分析目的:分析算法的时空效率以便改进算法性能
1.3.1算法时间复杂度分析
        一个算法是由控制结构(顺序.分支和循环三种)和原操作(指固有数据类型的操作,如+ - * / ++ --等)构成的.算法执行时间取决于两者的综合效果. 
        一个算法的基本构成:控制语句1+原操作   .....控制语句n+原操作
算法分析方式:
        1.事后分析统计方法:编写算法对应程序,统计其执行时间
        *不能用绝对执行时间进行比较的因素:1.编写程序语言不同
                                       2.执行程序环境不同
                                       3.其他因素
        2.事前估算分析方法:撇开上述因素,认为算法的执行时间是问题规模n的函数

1.分析算法的执行时间:
        1.求出算法所有原操作的执行次数(也称为频度),他是问题规模n的函数,用T(n)表示
        2.算法执行时间大致=原操作所需的时间*T(n).所有T(n)与算法的执行时间成正比.为此T(n)表示算法的执行时间.
        3.比较不同算法的T(n)大小得出算法执行时间的好坏
2.算法的执行时间用时间复杂度来表示
        算法中执行时间T(n)是问题规模n的某个函数f(n),记作:T(n)=O(f(n))
        记号"O"读作大o,它表示随问题规模n的增大算法执行时间的增长率和f(n)的增长率相同-->趋势分析
        "O"的形式定义为:T(n)=O(f(n))表示存在一个正的常数M使得当n>=n0时都满足:|T(n)|<=M|f(n)|,f(n)是T(n)的上界
        大致情况: T(n)/f(n)=M   n->无穷
        *只求出最高阶,忽略其低阶项和常系数,可简化T(n)的计算,比较客观的反映出当n很大时算法的时间性能.
        ej. T(n)=2n^2+2n+1=O(n^2)
一般地:  
        一个没有循环算法的执行时间与问题规模n无关,记作O(1),也称作常数阶
        一个只有一重循环的算法的执行时间与问题规模n的增长呈线性增大关系,记作O(n),也称线性阶        
        其余常用的算法时间复杂度还有平方阶O(n^2) 立方阶O(n^3) 对数阶O(log2n) 指数阶O(2^n)等
3.简化的算法时间复杂度分析:
        算法中的基本操作一般是最深层内的原操作
        算法执行时间大致=基本操作所需的时间*其运算次数
        转化为:
        在算法分析时,计算T(n)时仅仅考虑基本操作的运算次数
1.3.2算法空间复杂度分析
        空间复杂度:用于量度一个算法在运行过程中临时占用的存储空间大小
        一般也作为问题规模n的函数,采用数量级形式描述,记作S(n)=O(g(n))
        若一个算法的空间复杂度O(1),则称此算法为原地工作或就地工作算法
为什么空间复杂度分析只考虑临时占用的存储空间?
        如果考虑形参的空间,就重复累计了执行整个算法所需的空间
        1.4其他情况的算法分析
1.4.1最好.最坏和平均时间复杂度分析
        定义:设一个算法的输入规模为n,D[n]是所有输入的集合,任一输入I属于D[n],P(I)是I出现的概率,有sum[P[I],I属于D[n]]=1,T(I)是算法在输入I下的执行时间,则算法的平均时间复杂度为
             A(n)=sum[P(I)*T(I),I属于D[n]]
1.4.2递归算法的时空复杂度分析
        递归算法是指算法中出现调用自己的成分
        *递归算法分析也称为变长时空分析
        *非递归算法分析也称为定长时空分析
        ej.1-7
        void fun(int a[],int n,int k)    //数组a共有n个元素
        {  int i;
           if(k==n-1)
           {   for(i=0;i<n;i++)          //n次
               {    printf("%d\n",a[i]);    
               }     
           }
           else
           {   for(i=k;i<n;i++)          //n-k次
               {    a[i]=a[i]+i*i;        
               }
               fun(a,n,k+1);
           }    
         }      
         调用上述语句为fun(a,n,0);
         其时间复杂度为:
         执行时间为T(n),fun(a,n,k)执行时间为T1(n,k)-->T(n)=T1(n,0)
         递归算法知:
         T1(n,k)=n ;               当k=n-1时,
         T1(n,k)=(n-k)+T1(n,k+1) ; 其他情况.             
         则T(n)=T1(n,0)
               =n+T1(n,1)=....=n+(n-1)+...+3+2+T1(n,n-1)
               =n+(n-1)+...+3+2+n
               =O(n^2)         
         其空间复杂度为:
         空间为S(n),fun(a,n,k)执行时间为S1(n,k)-->S(n)=S1(n,0)
         递归算法知:
         S1(n,k)=1 ;               当k=n-1时,
         S1(n,k)=1+S1(n,k+1) ;     其他情况.     
         则S(n)=S(n)S1(n,0)
               =1+S1(n,1)=....=1+1+1+1+...+1(n个1)
               =O(n)
2.线性表         
2.1线性表的基本概念         
2.1.1线性表的定义
         线性表是一个具有相同特性的数据元素的有限序列
         相同特性:所有元素属于同一个数据类型
         有限:数据元素个数是有限的
         序列:数据元素由逻辑序号唯一确定,一个线性表中可以有相同值的元素
         线性表中所含元素的个数叫做线性表的长度,用n表示,n>=0.n=0时,表示线性表是一个空表,即表中不包含任何元素.
线性表的逻辑表示为:
         (a1,a2,...,ai,ai+1,...,an)
         ai(1<=i<=n)表示第i(i表示逻辑位序)个元素
         a1是表头元素,an是表尾元素       
2.1.2线性表的运算       
         1.初始化线性表InitList(&L):构造一个空的线性表
         2.销毁线性表DestroyList(&L):释放线性表L占用的内存空间
         3.判断线性表是否为空表ListEmpty(L):若L为空表,则返回真,否则返回假
         4.求线性表的长度ListLength(L):返回L中元素个数n
         5.输出线性表PrintList(L):线性表不为空时,顺序显示L中各节点的值域 
         6.求线性表L中指定位置的某个数据元素GetElem(L,i,&e):用e返回L中第i(1<=i<=n)个元素的值
         7.定位查找LocateElem(L,e):返回L中第一个值域与e相等的逻辑位序若这样的元素不存在,怎返回为0
         8.插入一个数据元素ListInsert(&L,i,e)在L的第i(1<=i<=n)个元素之前插入新的元素e,L的长度加1         
         9.删除数据元素ListDelete(&L,i,&e):删除L的第i(1<=i<=n)个元素,并用e返回其值,L的长度减1
线性表的作用:
         直接使用它来存放数据---作为存放数据的容器    
         直接使用它的基本运算---完成更复杂的功能
2.1.3线性表的知识结构
         线性表的概念->线性表ADT=逻辑结构+基本运算(运算描述)
               |                    |
               |                逻辑特性
        线性表的存储结构:   1.顺序存储结构->顺序表中基本运算的实现
               |           2.链式存储结构: 1.单链表
               |                          2.双链表
               |                          3.循环链表
          线性表的应用
               |
          特殊线性表-有序表
          
          
2.2线性表的顺序存储结构
2.2.1线性表的顺序存储--顺序表
         线性表的顺序存储结构:把线性表中的所有元素按照顺序存储方法进行存储
                             (按逻辑顺序依次存储到存储器中一片连续的存储空间中)
         线性表(a1,a2,...,ai,...,an)
         直接映射到
               0, 1, ..,i-1,..,n-1,..MaxSize-1
         顺序表a1,a2,...,ai,...,an, ..........,n->length         
顺序表类型定义:
         typedef struct
         {      ElemType data[MaxSize];
                int length
         }SqList;                            //顺序表类型       
         其中data成员存放元素,length成员存放线性表的实际长度
         说明:注意逻辑位序和物理位序相差1
2.2.2顺序表运算的实现
1.建立顺序表
         a[0...n-1]->顺序表L-整体创建顺序表
         int CreatList(SqList &L,int n) 
	{
		L.elem=(ElemType*)malloc(sizeof(ElemType)*LISTINITSIZE);
		if(!L.elem)     //L.elem为空 
		{       exit(-1);   //内存返还出错 
		}
		L.length=n;
		L.listsize=LISTINITSIZE;
		printf("请输入%d个数据\n",n); 
		for(int i=1;i<=L.length;i++)
		{       scanf("%d",&L.elem[i-1]);
		}
		 return 1;      //成功 
	}
算法参数说明
         1.顺序表指针的含义
         2.顺序表指针引用:
         int CreatList(SqList &L,int n) 
         "SqList &L"引用参数,将执行结果传回实参
         "&"引用符号放在形参前面
         输出型参数均为使用"&",不论参数值是否改变
2.顺序表基本运算算法
1.初始化线性表InitList(&L)
         该运算结果是构造一个空的线性表L,实际上只需将length成员设置为0即可       
          initlist(SqList &L)
	{       L.elem=(ElemType*)malloc(sizeof(ElemType)*LISTINITSIZE);   //分配存放线性表的顺序表空间
	        if(!L.elem)
		{exit(-1);
                }
		L.length=0;
		L.listsize=LISTINITSIZE;
		return 1 ;
	}
2.销毁线性表DestroyList(&L) 
        该运算结果是释放线性表L占用内存空间
        int DestroyList(&L)
        {free(L);}
        释放L所指向的空间
3.判断线性表是否为空表ListEmpty(L)
        该运算返回一个值表示L是否为空表,若L为空表,则返回true,否则返回false 
        bool ListEmpty(SqList *L)
        {return(L.length==0);}
4.求线性表的长度ListLength(L)
        int ListLength(SqList *L)
        {return(L.length);}
5.输出线性表PrintList(L)
        该运算当线性表L不为空时,顺序显示L中各元素的值
        void PrintList(SqList L)
	{       printf("该顺序表输出为:\n");
			for(int i=1;i<=L.length;i++)
		{       printf("%3d",L.elem[i-1]);
		}
		printf("\n");
	}
6.求线性表L中指定位置的某个数据元素GetElem(L,i,&e)
7.定位查找LocateElem(L,e):
        该运算顺序查找第1个值域与e相等的元素的逻辑位序,若这样的元素不存在,则返回值为0
        int LocateElem(SqList L,ElemType x)
        {       int i=1;
	        while(i<=L.length&&L.elem[i-1]!=x) 
		i++;
	
	        if(i<=L.length)
	        {return i;
                }
	        else { return 0;
	        }
        }
8.插入一个数据元素ListInsert(&L,i,e)
        该运算在顺序表L的第i(1<=i<=ListLength(L)+1)个位置上插入新的元素e
       int ListInsert(SqList &L,int i,ElemType x) //表第i个位置插入一个数 
	{ 
		if(i<1||i>L.length+1)  //1~n+1 
		{       return 0;
		}
		if(L.length>=L.listsize)
		{
		 L.elem=(ElemType*)realloc(L.elem,(L.listsize+INCREMENT)*sizeof(ElemType));
		 if(!L.elem)
		 {      exit(-2);     //内存溢出 
                 }
		L.listsize+=INCREMENT;
		}
		for(int j=L.length-1;j>=i-1;j--) 
		{
			L.elem[j+1]=L.elem[j];
		}
		L.elem[i-1]=x;
		L.length++;
		return 1 ;
	}
        对于本算法来说,元素移动的次数不仅与表长L.length=n有关,而且与插入位置有关
        当i=n+1时,移动次数为0;                  算法最好时间复杂度为O(1)
        当i=1时,移动次数为n,达到最大值;          算法最坏时间复杂度为O(n)
 平均情况分析
        ^a1^a2^...^ai^ai+1^...^an^ 在线性表L中共有n+1个可以插入的元素的地方
        在插入元素ai时,若为等概率情况,则pi=1/(n+1)
        此时需要将ai~an的元素均后移一个位置,共移动n-i+1个元素
        所以在长度为n的线性表中插入一个元素时所需要移动元素的平均次数为:n/2
        因此插入算法的平均时间复杂度为O(n)
  9.删除数据元素ListDelete(&L,i,&e)     
        int ListDlete(SqList &L,int i,ElemType &x)
{
	if(i<1||i>L.length)
	{
		return 0;   //1~n
	}
	x=L.elem[i-1];
	for(int j=i;j<=L.length-1;j++)
	{
		 L.elem[j-1]=L.elem[j];
	}
	L.length--;
	return 1;
}
